/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

// Table 10. Register boundary addresses
// RCC base and register
#define RCC_BASE_ADDR (0x40023800)
#define RCC_AHB1ENR_OFFSET (0x30)
#define RCC_AHB1ENR                                                            \
    (*((volatile uint32_t*)(RCC_BASE_ADDR + RCC_AHB1ENR_OFFSET)))

// GPIOA base and registers
#define GPIOA_BASE_ADDR (0x40020000)
#define GPIOA_MODER (*((volatile uint32_t*)(GPIOA_BASE_ADDR + 0x00)))
#define GPIOA_PUPDR (*((volatile uint32_t*)(GPIOA_BASE_ADDR + 0x0C)))
#define GPIOA_IDR (*((volatile uint32_t*)(GPIOA_BASE_ADDR + 0x10)))

// GPIOD base and registers
#define GPIOD_BASE_ADDR (0x40020C00)
#define GPIOD_MODER (*((volatile uint32_t*)(GPIOD_BASE_ADDR + 0x00)))
#define GPIOD_OTYPER (*((volatile uint32_t*)(GPIOD_BASE_ADDR + 0x04)))
#define GPIOD_PUPDR (*((volatile uint32_t*)(GPIOD_BASE_ADDR + 0x0C)))
#define GPIOD_ODR (*((volatile uint32_t*)(GPIOD_BASE_ADDR + 0x14)))

#define __NOP() __asm volatile("nop")

#define DELAY_LOOP_COUNTER 1000000

// typedef struct {
//	uint32_t resvervd [12];
//	uint32_t AHB1ENR ;
//
// }RCC;
// #define RCC_Typedef ((((RCC* )(RCC_BASE_ADDR))))

// Delay using a for loop counter
void delay_forLoop(uint32_t ms)
{
    for (int32_t i = 0; i < DELAY_LOOP_COUNTER; i++)
    {
        __NOP();
    }
}
int main(void)
{

    // RCC 16MHz
    //
    RCC_AHB1ENR |= (1U << 0); // enable GPIOA

    // configuration for GPIOA PIN 0
    // INPUT
    GPIOA_MODER &= ~(1U << 0);
    GPIOA_MODER &= ~(1U << 1);
    // // pull down
    // GPIOA_PUPDR &= ~(1U << 0);
    // GPIOA_PUPDR |= (1U << 1);

    // enable RCC clock for GPIOD
    RCC_AHB1ENR |= (1U << 3); // enble GPIOD
                              // configuration for GPIOD OUTPUT
                              // PIN 12
    GPIOD_MODER &= ~(3U << (12 * 2));
    GPIOD_MODER |= (1U << 24);
    GPIOD_MODER &= ~(1U << 25);
    // PIN 13
    GPIOD_MODER &= ~(3U << (13 * 2));
    GPIOD_MODER |= (1U << 26);
    GPIOD_MODER &= ~(1U << 27);
    // PUSH PULL
    GPIOD_PUPDR &= ~(3U << (12 * 2));
    GPIOD_PUPDR &= ~(3U << (13 * 2));

    //
    // PIND 12 && PIN D13

    /* Loop forever */
    // GPIOD_ODR &= ~((1U << 12) | (1U << 13));

    while (1)
    {
        //		GPIOD_ODR |= (1U<<12)| (1U << 13);
        //		int8_t btn_status  = (GPIOA_IDR & (1U<< 1 ))!= 0;
        if ((GPIOA_IDR & (1U << 0)))
        {
            GPIOD_ODR ^= ((1U << 12) | (1U << 13));
            delay_forLoop(1000);
        }
    }
}